
Processor-FPGA Communication: Using FIFO
===========================================================

Credit
------------

- This section is **Modified From** `DE1 SoC ARM HPS and FPGA Addresses and Communication Cornell ece5760`_

.. _DE1 SoC ARM HPS and FPGA Addresses and Communication Cornell ece5760: https://people.ece.cornell.edu/land/courses/ece5760/DE1_SOC/HPS_peripherials/FPGA_addr_index.html

:Date: 20 Aug 2019


`Corresponding Project Folder`_
------------------------------------------

.. _Corresponding Project Folder: https://github.com/tesla-cat/Works-Done-In-Dzmitry-s-Lab-At-CQT/tree/master/Cyclone%20V%20SoC%20Control%20System/Quartus%20Project%20Stage%202

Dependency
-------------



Using FIFO: FPGA Part
------------------------

**Step 1** We will use **Platform Designer** to generate two **FIFOs**, **HPS to FPGA FIFO** and **FPGA to HPS FIFO**

.. figure:: imgs/Stage-2_ECE5760_Qsys_FIFO.png

- For **HPS to FPGA FIFO**, its **Output** will be **Exported** and will be connected to the Top-Level module **DE1_SoC_Computer**, please refer to `DE1_SoC_Computer verilog file`_ (**line 515**). 

.. code-block:: verilog
	
	// HPS to FPGA FIFO
	.fifo_hps_to_fpga_out_readdata      (hps_to_fpga_readdata),      //  fifo_hps_to_fpga_out.readdata
	.fifo_hps_to_fpga_out_read          (hps_to_fpga_read),          //   out.read
	.fifo_hps_to_fpga_out_waitrequest   (),                            //   out.waitrequest
	.fifo_hps_to_fpga_out_csr_address   (32'd1), //(hps_to_fpga_out_csr_address),   // fifo_hps_to_fpga_out_csr.address
	.fifo_hps_to_fpga_out_csr_read      (1'b1), //(hps_to_fpga_out_csr_read),      //   csr.read
	.fifo_hps_to_fpga_out_csr_writedata (),                              //   csr.writedata
	.fifo_hps_to_fpga_out_csr_write     (1'b0),                           //   csr.write
	.fifo_hps_to_fpga_out_csr_readdata  (hps_to_fpga_out_csr_readdata),		//   csr.readdata

- To use this **Output** of **HPS to FPGA FIFO**, we must write by ourselves a **State Machine** to handle **Reading Data From HPS**, please refer to `DE1_SoC_Computer verilog file`_ (**line 440**). Specifically, HPS to FPGA FIFO **Reader** state machine waits for data in the FIFO, then reads the data into a buffer and **sets a ready flag**. The **csr-register** used to wait is the **status register**, so that only bit 0 (full) and bit 1 (empty) are read 

.. code-block:: verilog

	// =================================
	// HPS_to_FPGA state machine
	//==================================
	// Is there data in HPS_to_FPGA FIFO
	// and the last transfer is complete
	if (HPS_to_FPGA_state == 8'd0 && !(hps_to_fpga_out_csr_readdata[1]) && !data_buffer_valid)  begin
		hps_to_fpga_read <= 1'b1 ;
		HPS_to_FPGA_state <= 8'd2 ; //
	end
	
	// delay
	if (HPS_to_FPGA_state == 8'd2) begin
		// zero the read request BEFORE the data appears 
		// in the next state!
		hps_to_fpga_read <= 1'b0 ;
		HPS_to_FPGA_state <= 8'd4 ;
	end
	
	// read the word from the FIFO
	if (HPS_to_FPGA_state == 8'd4) begin
		data_buffer <= hps_to_fpga_readdata ; // send back data
		data_buffer_valid <= 1'b1 ; // set the data ready flag
		hps_to_fpga_read <= 1'b0 ;
		HPS_to_FPGA_state <= 8'd0 ; //6
	end

- For **FPGA to HPS FIFO**, its **Input** will be **Exported** and will be connected to the Top-Level module **DE1_SoC_Computer**, please refer to `DE1_SoC_Computer verilog file`_ (**line 525**). 

.. code-block:: verilog

	// FPGA to HPS FIFO
	.fifo_fpga_to_hps_in_writedata      (fpga_to_hps_in_writedata),      // fifo_fpga_to_hps_in.writedata
	.fifo_fpga_to_hps_in_write          (fpga_to_hps_in_write),          //                     .write
	.fifo_fpga_to_hps_in_csr_address    (32'd1), //(fpga_to_hps_in_csr_address),    //  fifo_fpga_to_hps_in_csr.address
	.fifo_fpga_to_hps_in_csr_read       (1'b1), //(fpga_to_hps_in_csr_read),       //                         .read
	.fifo_fpga_to_hps_in_csr_writedata  (),  //                         .writedata
	.fifo_fpga_to_hps_in_csr_write      (1'b0),      //                         .write
	.fifo_fpga_to_hps_in_csr_readdata   (fpga_to_hps_in_csr_readdata),    //   

- To use this **Input** of **FPGA to HPS FIFO**, we must write by ourselves a **State Machine** to handle **Writing Data To HPS**, please refer to `DE1_SoC_Computer verilog file`_ (**line 466**). Specifically, FPGA to HPS FIFO **Writer** state machine waits for space in the **FPGA to HPS FIFO** then writes the data to the FIFO and **clears the ready flag**

.. code-block:: verilog

	// =================================
	// FPGA_to_HPS state machine
	//================================== 
	// is there space in the 
	// FPGA_to_HPS FIFO
	// and data is available
	if (FPGA_to_HPS_state==0 && !(fpga_to_hps_in_csr_readdata[0]) && data_buffer_valid) begin
		fpga_to_hps_in_writedata <= data_buffer ;	
		fpga_to_hps_in_write <= 1'b1 ;
		FPGA_to_HPS_state <= 8'd4 ;
	end
	
	// finish the write to FPGA_to_HPS FIFO
	//if (HPS_to_FPGA_state == 8'd8) begin
	if (FPGA_to_HPS_state==4) begin
		fpga_to_hps_in_write <= 1'b0 ;
		data_buffer_valid <= 1'b0 ; // used the data, so clear flag
		FPGA_to_HPS_state <= 8'd0 ;
	end



.. _DE1_SoC_Computer verilog file: https://github.com/tesla-cat/Works-Done-In-Dzmitry-s-Lab-At-CQT/blob/master/Cyclone%20V%20SoC%20Control%20System/Quartus%20Project%20Stage%202/Cornell%20ECE5760/Top%20Level%20Entity%20for%20FPGA/DE1_SoC_Computer.v#L515

**Step 2** FIFO Settings

- Note that **Allow Backpressure** should be **off** 

.. figure:: imgs/Stage-2_ECE5760_Qsys_FIFO_Settings.png

**Step 3** Some Remarks

- Timing for the FIFO read/write is not specified in the users manual! The HPS-to-FPGA read operation takes TWO cycles but the read-enable line **can only be held high for ONE cycle**, Holding it high for two cycles results in two reads. 
- The HPS program asks the user for the number of items to send (0<N<500), reads the fill-level of each of the FIFOs, then prints out the returned values and fill levels. 

.. figure:: imgs/Stage-2_ECE5760_C_Program_Result.png

- For N greater than 256, using block-write, that the FPGA-to-HPS FIFO will fill, then stall, while the HPS-to-FPGA FIFO keeps filling. 
- The nonblocking read/write macros in the HPS program are not well tested. 
- If you use nonblocking read/write that you must check the return value for success.

Using FIFO: Processor Part
-------------------------------

The following :code:`Quartus Project Stage 2\Cornell ECE5760\C Code for HPS\FIFO_2_prettified.c` is modified from the original file :code:`FIFO_2.c`. However, it is **not tested yet** since I still have doubt as can be seen below, hopefully my boss can help me with this: 

.. code-block:: c

	// FIFO details: 
	//     Depth: 256    Data Width: 32 bits

	#include <stdio.h>
	#include <string.h>
	#include <stdlib.h>
	#include <unistd.h>
	#include <fcntl.h>
	#include <sys/types.h>
	#include <sys/ipc.h> 
	#include <sys/shm.h> 
	#include <sys/mman.h>
	#include <sys/time.h> 
	#include <math.h> 
	    
	//?????????????????????????????
	    // main bus; scratch RAM. used only for testing
	    #define FPGA_ONCHIP_BASE      0xC8000000
	    #define FPGA_ONCHIP_SPAN      0x00001000
	    // main bus; FIFO write address
	    #define FIFO_BASE             0xC0000000
	    #define FIFO_SPAN             0x00001000
	    /// lw_bus; FIFO status address
	    #define HW_REGS_BASE          0xff200000
	    #define HW_REGS_SPAN          0x00005000 
	    /*
	    #define HW_REGS_BASE ( ALT_STM_OFST )
	    #define HW_REGS_SPAN ( 0x04000000 )
	    #define HW_REGS_MASK ( HW_REGS_SPAN - 1 )
	    */
	//?????????????????????????????

	//====================================
	// The following corresponds to **h2f_axi_master** in Platform Designer
	//====================================
	void *h2f_virtual_base;
	volatile unsigned int * FIFO_write_ptr = NULL ;
	volatile unsigned int * FIFO_read_ptr = NULL ;
	#define FIFO_WRITE           (*(FIFO_write_ptr))
	#define FIFO_READ            (*(FIFO_read_ptr))

	//====================================
	// The following corresponds to **h2f_lw_axi_master** in Platform Designer
	//====================================
	void *h2f_lw_virtual_base;
	volatile unsigned int * FIFO_write_status_ptr = NULL ;
	volatile unsigned int * FIFO_read_status_ptr = NULL ;
	#define WRITE_FIFO_FILL_LEVEL (*FIFO_write_status_ptr)
	#define READ_FIFO_FILL_LEVEL  (*FIFO_read_status_ptr)
	#define WRITE_FIFO_FULL       ((*(FIFO_write_status_ptr+1))& 1 ) 
	#define WRITE_FIFO_EMPTY      ((*(FIFO_write_status_ptr+1))& 2 ) 
	#define READ_FIFO_FULL        ((*(FIFO_read_status_ptr+1)) & 1 )
	#define READ_FIFO_EMPTY       ((*(FIFO_read_status_ptr+1)) & 2 )
	#define WAIT {} 

	//====================================
	// Helper Functions
	//====================================

	// Write and Read: **a** is data to be written, **b** is result(success/fail)
	#define FIFO_WRITE_BLOCK(a)         {while (WRITE_FIFO_FULL){WAIT};FIFO_WRITE=a;}
	#define FIFO_READ_BLOCK(a)          {while (READ_FIFO_EMPTY){WAIT};a=FIFO_READ;}
	#define FIFO_WRITE_NOBLOCK(a,b)     {b=!WRITE_FIFO_FULL; if(!WRITE_FIFO_FULL)FIFO_WRITE=a;}
	#define FIFO_READ_NOBLOCK(a,b)      {b=!READ_FIFO_EMPTY; if(!READ_FIFO_EMPTY)a=FIFO_READ;}

	int memoryMapping(){
	    // Step 1
	    if( (fd = open("/dev/mem",(O_RDWR|O_SYNC))) == -1 ){
	        printf( "ERROR: could not open \"/dev/mem\"...\n" );
	        return( 1 );
	    }
	    
	    // **h2f_axi_master** Part
	    h2f_virtual_base = mmap( NULL, FIFO_SPAN, ( PROT_READ | PROT_WRITE ), MAP_SHARED, fd, FIFO_BASE);     
	    if( h2f_virtual_base == MAP_FAILED ) {
	        printf( "ERROR: mmap() for **h2f_axi_master** failed\n");
	        close( fd );  return(1);
	    }
	    FIFO_write_ptr =(unsigned int *)(h2f_virtual_base);
	    FIFO_read_ptr  =(unsigned int *)(h2f_virtual_base + 0x10);
	    
	    // **h2f_lw_axi_master** Part
	    h2f_lw_virtual_base = mmap( NULL, HW_REGS_SPAN, ( PROT_READ | PROT_WRITE ), MAP_SHARED, fd, HW_REGS_BASE );    
	    if( h2f_lw_virtual_base == MAP_FAILED ) {
	        printf( "ERROR: mmap() for **h2f_lw_axi_master** failed...\n" );
	        close( fd );  return(1);
	    }
	    FIFO_write_status_ptr = (unsigned int *)(h2f_lw_virtual_base);
	    FIFO_read_status_ptr  = (unsigned int *)(h2f_lw_virtual_base + 0x20); //0x20
	        
	    return(0);
	}

	int repeatWriting(){
	    int i;
	    while(1){
	        printf( "repeatWriting: ");    
	        scanf("%d", &i);
	        FIFO_WRITE_BLOCK(i);
	        printf("Fill levels: WRITE_FIFO=%d READ_FIFO=%d\n", WRITE_FIFO_FILL_LEVEL, READ_FIFO_FILL_LEVEL);    
	    }
	    return(0);
	}

	//====================================
	// Main Function
	//====================================

	int main(void){
	    memoryMapping();
	    repeatWriting();
	} 