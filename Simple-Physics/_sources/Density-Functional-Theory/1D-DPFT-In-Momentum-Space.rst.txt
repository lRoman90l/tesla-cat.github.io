
1D DPFT In Momentum Space
==================================

Thomas Fermi Approximation
--------------------------

.. math::

   E_1^{TF}[T-\mu]=g\int {drdp\over (2\pi)^3}[ T(p)+V_{\text{ext}}(r)-\mu ]\eta(\mu -T-V_{\text{ext}}) \\
   \Rightarrow \rho={\delta E_1^{TF} \over \delta T}= g\int {dr \over (2\pi)^3} 1\cdot \eta(\mu -T-V_{\text{ext}})\\
   = g{1 \over (2\pi)^3} {4\over 3}\pi R^3={g \over 6\pi^3}R^3 \\
   \text{Where }R \text{ is the radius of the sphere such that } \mu -T-V_{\text{ext}}>0 

-  For harmonic oscillator in 1D, we have

.. math::

   V=x^2\Rightarrow \mu -T- x^2>0 \Rightarrow x < \sqrt{\mu-T}\equiv R\\
   \Rightarrow \rho= g{1 \over 2\pi} 2R ={g \over \pi} \sqrt{\mu-T}

Effective Kinetic Envergy :math:`T`
-----------------------------------

.. math::

   T(p)={\delta \over \delta \rho}E_{\text{int}} +T_{\text{kin}}\\
   \text{where } T_{\text{kin}} = {1\over 2}p^2

The Interaction
---------------

-  I don’t know what :math:`E_{\text{int}}` should look like at the
   moment, let us just assume the same form as in [1D DPFT In Python] so
   that

.. math:: T_{\text{int}} = { \delta E_{\text{int}} \over \delta \rho}= w  \rho

Why momentum space ?
--------------------

-  As can be seen above, in position space, we have fixed expression for
   density :math:`n=\sqrt{\alpha^{-1}[\mu - V_{\text{ext}}]}`, this
   expression does not change, only :math:`V_{\text{ext}}` varies

-  In momentum space

-  We start with :math:`\mu -T- V_{\text{ext}}(r)>0`, then
   :math:`R=V_{\text{ext}}^{\text{Inv}}(\mu-T)` and :math:`\rho = {g\over 6\pi^3}R^3`

-  The position space and momentum space are only equivalent, at least
   computationally, for harmonic oscillators! And this is a result of
   the fundamental relation :math:`T={1\over 2}p^2`

-  Therefore, depends on :math:`V_{\text{ext}}`, some problem may be
   easier to solve in momentum space!

Fermi Radius for Coulomb Potential (1D)
---------------------------------------

.. math::

   \begin{cases} 
       \mu -T- V_{\text{ext}}(r)>0 \\
       V_{\text{ext}}(r) = -{Z\over r} 
    \end{cases}  \Rightarrow r > -{Z\over \mu-T} 

-  I just realized that the above discussion does not apply to Coulomb
   potential! In this case the particle can only live **outside** Fermi
   Sphere, whereas for harmonic oscillator, the particle can only live
   **inside** !

Why is :math:`r<{Z\over T-\mu}` wrong?
--------------------------------------

.. math::

   {Z\over r}>T-\mu\\
   \Rightarrow {Z\over T-\mu}>r \;\;\text{This step is wrong since }T-\mu<0 

-  Still don’t agree? In **Equation (45)** in the paper, we demand
   :math:`-2[V-\mu]>0`, this means :math:`\mu > V`, and **Both effective
   potentials** :math:`T` and :math:`V` are the same **physical
   quantity**, so :math:`\mu > T` MUST HOLD!

- Yet another argument. If we adopt :math:`r > -{Z\over \mu-T}` , then if :math:`Z>0` (positive nucleus), :math:`r\in (0,\infty)`. If :math:`Z<0` (negative nucleus), :math:`r` must be larger than some threshold. These two physically makes sense!  

- Yet another argument, :math:`\mu > T` simply works! As shown in code below

- If you accept my arguments, than we must conclude that there is something missing with DPFT, :math:`\mu` cannot simply be treated as **lagrange multiplier**, there must be some relation that lead to :math:`\mu > T`

Simple DPFT in Momentum space (Hamonic Oscillator 1D)
-----------------------------------------------------

**The following code is successful and the result agrees with one in
position space, note that it uses the fact** :math:`\mu>T`

.. code:: python

    import numpy as np
    import matplotlib.pyplot as plt
    
    class SimpleDPFT:
      def __init__(self,args):
        self.Tkin = args["Tkin"]
        self.maxIteration = args["maxIteration"]
        self.mu = args["mu"]
        self.g = args["g"]
        self.N = args["N"]
        self.dp = args["dp"]
        self.learningRate = args["learningRate"]
        self.gradientMax = args["gradientMax"]
        self.w = args["w"]
        self.p = args["p"]
        self.nChangeMax = args["nChangeMax"]
      
      def selfConsistentLoop(self):
        self.T = self.Tkin
        self.mu = self.enforceN(self.mu)
        self.n = self.getDensity(self.mu)
        for i in range(self.maxIteration):
          self.T = self.Tkin + self.w * self.n
          self.mu = self.enforceN(self.mu)
          nOld = self.n
          self.n = (1-self.p)*self.n + self.p*self.getDensity(self.mu)
          if(np.sum(abs(self.n-nOld))<self.nChangeMax):
            break
        return self.n
    
      def enforceN(self, mu):
        # gradient descent
        for i in range(self.maxIteration):
          gradient = (self.cost(mu+1)-self.cost(mu))
          mu = mu - self.learningRate * gradient
          if(abs(gradient)<self.gradientMax):
            break
        return mu
      def cost(self, mu):
        return abs(self.N - np.sum(self.getDensity(mu)*self.dp) )
    
      def getDensity(self,mu):
        muMinusT = mu - self.T
        muMinusT[ muMinusT<0 ] = 0
        return self.g/np.pi * np.sqrt(muMinusT)
    
    # =================================================
    # ================= Usage =========================
    # =================================================
    p = np.linspace(-10, 10, num=100)
    dp = p[1]-p[0]
    args = {
        "Tkin": p**2/2,
        "maxIteration": 4000,
        "mu": 1,
        "g": 1,
        "N": 20,
        "dp": dp,
        "learningRate": 1e-1,
        "gradientMax": 1e-6,
        "w": 5,
        "p": 0.5,
        "nChangeMax": 1e-6,
    }
    
    for w in range(3):
      args["w"] = w*5
      simpleDPFT = SimpleDPFT(args)
      n = simpleDPFT.selfConsistentLoop()
      print("Particle Number Check:", np.sum(n)*dp,"/ 20")
      plt.plot(p,n,label="w="+str(w*5))
    plt.legend()
    plt.show()



.. parsed-literal::

    Particle Number Check: 19.65459900651429 / 20
    Particle Number Check: 19.560823172965314 / 20
    Particle Number Check: 19.494538379097083 / 20



.. image:: imgs/1D-DPFT-In-Momentum-Space/output_8_1.png

